  <!--
Breath Plot: COVID-19 VentMon analysis software
    Copyright (C) 2022  Robert L. Read

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU Affero General Public License as
    published by the Free Software Foundation, either version 3 of the
    License, or (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU Affero General Public License for more details.

    You should have received a copy of the GNU Affero General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
  -->

  <head>
	<!-- Load plotly.js into the DOM -->
	<script src='https://cdn.plot.ly/plotly-latest.min.js'></script>
</head>
<label for="dserver">PIRDS data server url:</label>
<input type="text" id="dserverurl" name="dserverurl" size="50">
  <button id="useofficial">Use Ventmon Data Lake: ventmon.coslabs.com</button>
<br><br>
<label for="traceid">Trace ID             :</label>
<input type="text" id="traceid" name="traceidinput" size="50">
<br><br>
<label for="num_to_read">Number of samples to Read and Plot:</label>
  <input type="text" id="num_to_read" name="num_to_read" size="10"><br><br>

  <button id="startoperation">Start Interactive Plot</button>
  <button id="stopoperation">Stop Interactive Plot</button>

  <label for="bpm">BPM: </label>
  <label id="bpm"> </label>

  <label for="tv">Tidal Volume: </label>
  <label id="tv"> </label>

  <label for="mv">Mintue Volume: </label>
  <label id="mv"> </label>

  <label for="ier">I:E ratio: </label>
  <label id="ier"> </label>

<body>
  <div id='PFGraph'><!-- Pressure and Flow Graph --></div>
  <div id='EventsGraph'><!-- Events --></div>
<div>
  <button id="plot">Read from Server and Plot</button>
</div>
<div>
  <button id="import">Import Trace</button>
  <button id="export">Export Trace</button>
  </div>
<div>
  <textarea id="json_trace" rows="30" cols="80"></textarea>
  </div>

<p>
This is a work in progress of <a href="https://www.pubinv.org">Public Invention</a>.

<p>
This is a tester tool for open-source ventilators.
  It uses the <a href="https://github.com/PubInv/respiration-data-standard">PIRDS data format</a>.

<p>
The basic operation is receive data from web server specified in the URL above.
  Probably for now that will be the VentMon Python web server that
listens on a serial port for the VentMon device or any other
device that streams PIRDS events.

</body>
  <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>

  <script>

function getParameterByName(name, url) {
    if (!url) url = window.location.href;
    name = name.replace(/[\[\]]/g, '\\$&');
    var regex = new RegExp('[?&]' + name + '(=([^&#]*)|&|#|$)'),
        results = regex.exec(url);
    if (!results) return null;
    if (!results[2]) return '';
    return decodeURIComponent(results[2].replace(/\+/g, ' '));
}

const VENTMON_DATA_LAKE = "http://ventmon.coslabs.com";
const queryString = window.location.search;
const urlParams = new URLSearchParams(queryString);
var TRACE_ID = urlParams.get('i')
var DSERVER_URL = window.location.protocol + "//" + window.location.host;
var NUM_TO_READ = 2000;

var DATA_RETRIEVAL_PERIOD = 50;

var RESPIRATION_RATE_WINDOW_SECONDS = 20;

var intervalID;


// This sould be better as time, but is easier
// to do as number of samples.
const MAX_SAMPLES_TO_STORE_S = 4000;
var samples = [];
var INITS_ONLY = true;

// This is just to get the party started!
function init_samples() {
    return [
	{
	    "event": "M",
	    "type": "P",
	    "ms": 19673310,
	    "loc": "A",
	    "num": "0",
	    "val": 10111
	},
	{
	    "event": "M",
	    "type": "D",
	    "ms": 19673310,
	    "loc": "A",
	    "num": "0",
	    "val": 4
	},
	{
	    "event": "M",
	    "type": "F",
	    "ms": 19673310,
	    "loc": "A",
	    "num": "0",
	    "val": 0
	},
	{
	    "event": "M",
	    "type": "P",
	    "ms": 19673376,
	    "loc": "A",
	    "num": "0",
	    "val": 10111
	},
	{
	    "event": "M",
	    "type": "D",
	    "ms": 19673376,
	    "loc": "A",
	    "num": "0",
	    "val": 4
	},
	{
	    "event": "M",
	    "type": "F",
	    "ms": 19673376,
	    "loc": "A",
	    "num": "0",
	    "val": 0
	},
	{
	    "event": "M",
	    "type": "P",
	    "ms": 19673442,
	    "loc": "A",
	    "num": "0",
	    "val": 10110
	},
	{
	    "event": "M",
	    "type": "D",
	    "ms": 19673442,
	    "loc": "A",
	    "num": "0",
	    "val": 3
	},
    ];
}



function unpack(rows, key) {
    return rows.map(function(row) { return row[key]; });
}

const CONVERT_PIRDS_TO_SLM = 1/1000;

// we have now changed this, there will be flow and
// pressure in the same samples, and we should filter.
// TODO: I need to add maximal start and end
// samples to equalize all the plots.
function samplesToLine(samples) {
    var flows = samples.filter(s => s.event == 'M' && s.type == 'F');

    // These are slm/1000, or ml/minute...
    // so we multiply by 1000 to get liters per minute
    var flow_values = unpack(flows,"val").map(v => v * CONVERT_PIRDS_TO_SLM);
    var fmillis = unpack(flows, 'ms');
    // Convert to seconds...
    var fmin = Math.min(...fmillis);
    var fzeroed = fmillis.map(m =>(m-fmin)/1000.0);

    var pressures = samples.filter(s => s.event == 'M' && s.type == 'D' && s.loc == 'A');

    var pmillis = unpack(pressures, 'ms');
    var pmin = Math.min(...pmillis);
    var pzeroed = pmillis.map(m =>(m-pmin)/1000.0);
    // the PIRDS standard is integral mm H2O, so we divide by 10
    var delta_p = unpack(pressures, 'val').map(p => p / 10);
    var diff_p = {type: "scatter", mode: "lines",
		  name: "pressure",
		  x: pzeroed,
		  y: delta_p,
		  line: {color: "#FF0000"}
		 };

  var flow = {type: "scatter", mode: "lines",
		name: "flow",
		x: fzeroed,
	      y: flow_values,
              xaxis: 'x2',
              yaxis: 'y2',
              fill: 'tozeroy',
		line: {color: '#0000FF'}
             };

  var max_flow = flow_values.reduce(
    function(a, b) {
      return Math.max(Math.abs(a), Math.abs(b));
    }
    ,0);
  var scaled_flow = flow_values.map(f => 100.0 * (f / max_flow));
  var flow_hollow = {type: "scatter", mode: "lines",
		name: "flow ghost",
		     x: fzeroed,
                     // Convert to a percentage
	             y: scaled_flow,
		line: {color: '#8888FF'}
               };
  return [diff_p,flow,flow_hollow];
}
function plot(samples, trans, breaths) {
  var new_data = samplesToLine(samples);
  var millis = unpack(samples, 'ms');
  var min = Math.min(...millis);
  var zeroed = millis.map(m =>(m-min)/1000.0);

  {
    var layout = {
      title: 'VentMon Breath Analysis',
      xaxis: {domain: [0.1, 0.9]},
      yaxis: {
        title: 'Airway P(cm H2O)',
        titlefont: {color: 'red'},
        tickfont: {color: 'red'},
      },
      xaxis2: {domain: [0.1, 0.9]},
      yaxis2: {
        title: 'Flow l/minute',
        titlefont: {color: 'blue'},
        tickfont: {color: 'blue'}
      },
      grid: {
        rows: 2,
        columns: 1,
        pattern: 'independent',
        roworder: 'top to bottom'}
    }

    var double_plot = [new_data[0],new_data[1]];

    Plotly.newPlot('PFGraph', double_plot, layout);
  }

  // The Y-axis for the events will be percentage.
  // This is somewhat abstract; each trace has
  // a different meaning. In general it will be
  // % as a function of some known value, which
  // will be either a limit or a min or max.
  {
    var event_graph = [];
    if (trans) {
      // Transitions are simply scaled to 50%.
      var tmillis = unpack(trans, 'ms');
      var tzeroed = tmillis.map(m =>(m-min)/1000.0);
      var tstates = unpack(trans, 'state');
      var tstates_amped = tstates.map(m =>m*50);
      var transPlot = {type: "scatter", mode: "lines",
		       name: "trans",
		       x: tzeroed,
		       y: tstates_amped,
//                       xaxis: 'x2',
//                       yaxis: 'y2',
		       line: {color: 'dkGreen'}
		      };
      // We add a hollow flow line to see in position..
      event_graph.push(new_data[2]);
      event_graph.push(transPlot);
    }

    if (breaths) {
      var bmillis = unpack(breaths, 'ms');
      var bzeroed = bmillis.map(m =>(m-min)/1000.0);
      // I'm goint to a add start and end transition to make the plot
      // come out right
      var ys = breaths.map( b => 0);
      var breathPlot = {type: "scatter", mode: "markers",
		        name: "Transitions",
		        x: bzeroed,
		        y: ys,
//                       xaxis: 'x3',
//                       yaxis: 'y3',
		        marker: { size: 12, color: "red" },
                        textposition: 'bottom center',
                        text: bzeroed
		       };
      event_graph.push(breathPlot);
      // Now I attempt to extract volumes...
      // Our breaths mark the END of a breath..
      // so we want to draw the volumes that way.
      const volume_ht_factor = 20;
      var max_exh = unpack(breaths,'vol_e').reduce(
        function(a, b) {
          return Math.max(Math.abs(a), Math.abs(b));
        }
        ,0);
      var max_inh = unpack(breaths,'vol_i').reduce(
        function(a, b) {
          return Math.max(Math.abs(a), Math.abs(b));
        }
        ,0);
      var max_v = Math.max(max_inh,max_exh);

      var exh_v = unpack(breaths, 'vol_e').map(e => 100 * e / max_v);
      var t_exh_v =  unpack(breaths, 'vol_e').map(e => Math.round(e*1000.0)+"ml exh");
      var inh_v = unpack(breaths, 'vol_i').map(i => 100 * i / max_v);
      var t_inh_v = unpack(breaths, 'vol_i').map(e => Math.round(e*1000.0)+"ml inh");
      // now to graph properly, I must find the center of an inhalation.
      // I have packed these into the breaths...
      var inhale_centers = breaths.map(b => (trans[b.trans_begin_inhale].ms + trans[b.trans_cross_zero].ms - 2*min) / (2.0 * 1000.0));
      var exhale_centers = breaths.map(b => (trans[b.trans_cross_zero].ms + trans[b.trans_end_exhale].ms - 2*min) / (2.0 * 1000.0));

      var inhPlot = {type: "scatter", mode: "markers+text",
                     name: "Inh. ml",
                     textposition: 'bottom center',
                     x: inhale_centers,
                     y: inh_v,
                     text: t_inh_v,
                     marker: { size: 12, color: "black" }
                    };
      var exhPlot = {type: "scatter", mode: "markers+text",
                     name: "Exh. ml",
                     textposition: 'top center',
                     x: exhale_centers,
                     y: exh_v,
                     text: t_exh_v,
                     marker: { size: 12, color: "green" }
                    };
      event_graph.push(inhPlot);
      event_graph.push(exhPlot);
    }

    // I'm going to try putting the pressure
    // in faintly to make the graphs match

    var event_layout = {
      title: 'Events',
      xaxis: {domain: [0.1, 0.9]},
      yaxis: {
        range: [-100.0, 100.0]
      },
    };
    Plotly.newPlot('EventsGraph', event_graph,event_layout);
  }
}

// This is probably the dumbest possible respriation rate...
// it counts breaths but makes no attempt to comute the avergae,
// which would allow a smoother change...
function compute_respiration_rate(secs,samples,transitions,breaths) {
  // In order to compute the number of breaths
  // in the last s seconds, I compute those breaths
  // whose time stamp is s seconds from the most recent sample

  if (breaths.length == 0) {
    return [0,0,0,"NA"];
  } else {
    const recent_ms = samples[samples.length - 1].ms;
    var cur_ms = recent_ms;
    var cnt = 0.0;
    var vol_i = 0.0;
    var vol_e = 0.0;
    var i = breaths.length - 1;
    var time_inh = 0;
    var time_exh = 0;
    while((i >=0) && (breaths[i].ms > (cur_ms - secs*1000))) {
      cnt++;
      vol_i += breaths[i].vol_i;
      time_inh +=
        (transitions[breaths[i].trans_cross_zero].ms -
        transitions[breaths[i].trans_begin_inhale].ms);

      vol_e += breaths[i].vol_e;
      time_exh +=
        (transitions[breaths[i].trans_end_exhale].ms -
        transitions[breaths[i].trans_cross_zero].ms);
      i--;
    }
    if (cnt > 1) {
      var duration_minutes = secs / 60.0;
      var minute_volume = (1000) * vol_i / duration_minutes;
      var tidal_volume = (1000) * vol_i / cnt;

      var EIratio = (time_inh == 0) ? null : time_exh / time_inh;
      return  [(cnt * 60.0) / secs,
               tidal_volume, minute_volume,
               EIratio];
    } else {
      return [0,0,0,"NA"];
    }
  }
}

function process(samples) {
  const t = 200; // size of the window is 200ms
  const v = 50; // min volume in ml
  var [transitions,breaths] = computeMovingWindowTrace(samples,t,v);
  plot(samples,transitions,breaths);
  // How many seconds backwards should we look? Perhaps 20?
  var [bpm,tv,mv,EIratio] = compute_respiration_rate(RESPIRATION_RATE_WINDOW_SECONDS,samples,transitions,breaths);
  $("#bpm").text(bpm.toFixed(1));
  $("#tv").text(tv.toFixed(1));
  $("#mv").text(mv.toFixed(1));
  if (EIratio == "NA") {
    $("#ier").text("NA");
  } else {
    $("#ier").text((1.0 / EIratio).toFixed(1));
  }
}

function retrieveAndPlot(){
  var trace_piece = (TRACE_ID) ? "/" + TRACE_ID : "";
  DSERVER_URL = $("#dserverurl").val();
  NUM_TO_READ = $("#num_to_read").val();
  var url =  DSERVER_URL + trace_piece + "/json?n="+ NUM_TO_READ;

  $.ajax({url: url,
          success: function(cur_sam){
	    if (INITS_ONLY) {
	      samples = cur_sam;
	      INITS_ONLY = false;
	    } else {
              var discard = Math.max(0,
                                     samples.length + cur_sam.length - MAX_SAMPLES_TO_STORE_S);
	      samples = samples.slice(discard);
	    }
	    samples = samples.concat(cur_sam);
	    // We are not guaranteeed to get samples in order
	    // we sort them....
	    samples = samples.sort((a,b) => a.ms - b.ms);
            process(samples);
          },
          error: function(xhr, ajaxOptions, thrownError) {
	    console.log("Error!" + xhr.status);
	    console.log(thrownError);
          }
         });
}



// A simple computation of a moving window trace
// computing [A + -B], where A is volume to left
// of sample int time window t, and B is volume to right
// t is in milliseconds
function computeMovingWindowTrace(samples,t,v) {

  var flows = samples.filter(s => s.event == 'M' && s.type == 'F');
  var first_time = flows[0].ms;
  var last_time = flows[flows.length - 1].ms;
  var duration = last_time - first_time;

  // Here is an idea...
  // We define you to be in one of three states:
  // Inspiring, expiring, or neither.
  // Every transition between these states is logged.
  // Having two inspirations between an expiration is
  // weird but could happen.
  // We record transitions.
  // When the time series crossed a fixed threshold
  // or zero, it causes a transition. If you are inspiring,
  // you have to cross zero to transition to neither,
  // and you start expiring when you cross the treshold.
  const vm = 4;

  // We will model this as a list of transitions.
  // A breath is any number of inspirations followed by
  // any number of expirations. (I+)(E+)

  var transitions = [];
  var state = 0; // Let 1 mean inspiration, -1 mean expiration, 0 neither
  for(var i = 0; i < flows.length; i++) {
    var f = flows[i].val * CONVERT_PIRDS_TO_SLM;
    //    var ms = flows[i].ms-first_time;
    var ms = flows[i].ms;
    if (state == 0) {
      if (f > vm) {
	state = 1;
	transitions.push({ state: 1, sample: i, ms: ms})
      } else if (f < -vm) {
	state = -1;
	transitions.push({ state: -1, sample: i, ms: ms})
      }
    } else if (state == 1) {
      if (f < -vm) {
	state = -1;
	transitions.push({ state: -1, sample: i, ms: ms})
      } else if (f < 0) {
	state = 0;
	transitions.push({ state: 0, sample: i, ms: ms})
      }
    } else if (state == -1) {
      if (f > vm) {
	state = 1;
	transitions.push({ state: 1, sample: i, ms: ms})
      } else if (f > 0) {
	state = 0;
	transitions.push({ state: 0, sample: i, ms: ms})
      }
    }
  }

  // Now that we have transitions, we can apply a
  // diferrent algorithm to try to define "breaths".
  // Because a breath is defined as an inspiration
  // and then an expiration, we will define a breath
  // as from the first inspiration, until there has
  // been one expiration, until the next inspiration.
  var breaths = []
  var expiring = false;
  var last = 0;
  var voli = 0;
  var vole = 0;

  // This should be in liters...
  function integrateSamples(a,z) {
    // -1 for quadilateral approximation
    var vol = 0;
    for(var j = a; j < z-1; j++) {
      // I'll use qadrilateral approximation.
      // We'll form each quadrilateral between two samples.
      var ms = flows[j+1].ms - flows[j].ms;
      var ht = ((flows[j+1].val + flows[j].val )/2) * CONVERT_PIRDS_TO_SLM;
      // Flow is actually in standard liters per minute,
      // so to get liters we divide by 60 to it l/s,
      // and and divde by 1000 to convert ms to seconds.
      // We could do that here, but will move constants
      // to end...
      vol += ms * ht;
    }
    return vol/(60*1000);
  }
  var beg = 0;
  var zero = 0;
  for(var i = 0; i < transitions.length; i++) {
    // We're looking for the end of the inhalation here!!
    if (((i -1) >= 0) && transitions[i-1].state == 1 && transitions[i].state == 0) {
      zero = i;
    }
    if (expiring && transitions[i].state == 1) {
      breaths.push({ ms: transitions[i].ms,
		     sample: transitions[i].sample,
		     vol_e: vole,
		     vol_i: voli,
                     trans_begin_inhale: beg,
                     trans_cross_zero: zero,
                     trans_end_exhale: i,
		   }
		  );
      beg = i;
      expiring = false;
      vole = integrateSamples(last,transitions[i].sample);
      last = transitions[i].sample;
    }
    if (!expiring && transitions[i].state == -1) {
      expiring = true;
      voli = integrateSamples(last,transitions[i].sample);
      last = transitions[i].sample;
    }
    // At this point we can in theory compute an inspiratory volume..

  }

  return [transitions,breaths];
}


$("#useofficial").click(function() {
    DSERVER_URL = VENTMON_DATA_LAKE;
    $("#dserverurl").val(DSERVER_URL);
});

$("#import").click(function() {
    var input_trace = $("#json_trace").val();
    samples = JSON.parse(input_trace);
});

$("#export").click(function() {
    $("#json_trace").val(JSON.stringify(samples,null,2));
});

$("#plot").click(retrieveAndPlot);


  // Experimental timing against the data server



  // clearInterval(intervalID);
$("#startoperation").click( () => {
  if (typeof intervalID === 'undefined') {
    intervalID = setInterval(
      function() {
        retrieveAndPlot();
      },
      DATA_RETRIEVAL_PERIOD) }
}
                          );
$("#stopoperation").click( () =>
  clearInterval(intervalID)
);

$( document ).ready(function() {

  if (window.location.protocol == "http:")
    DSERVER_URL = window.location.protocol + "//" + window.location.host;
  else
    DSERVER_URL = "http://localhost";


  $( "#dserverurl" ).val( DSERVER_URL );
  $('#dserverurl').change(function () {
    DSERVER_URL = $("#dserverurl").val();
  });

  $( "#num_to_read" ).val( NUM_TO_READ );
  $('#num_to_read').change(function () {
    NUM_TO_READ = $("#num_to_read").val();
  });

  $( "#traceid" ).val( TRACE_ID );
  $('#traceid').change(function () {
    TRACE_ID = $("#traceid").val();
  });

  samples = init_samples();
  retrieveAndPlot();

});


  </script>
